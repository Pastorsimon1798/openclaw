{
  "url": "https://natesnewsletter.substack.com/p/why-dumb-agents-mean-smart-orchestration",
  "slug": "my-honest-field-notes-on-scaling-agents-past-the-demo-phase-6-rules-from-teams-r",
  "title": "My honest field notes on scaling agents past the demo phase + 6 rules from teams running hundreds",
  "subtitle": "Watch now | Turns out more does not actually mean better--and when it comes to agents, more is actually worse.",
  "author": "Nate",
  "published": "Mon, 26 Jan 2026 14:03:32 GMT",
  "content_html": "<p>A December 2025 study from Google and MIT found something I wasn&#8217;t expecting: adding more agents to a system can make it perform worse. Not diminishing returns&#8212;actual degradation. The researchers documented configurations where more agents produced worse outcomes than fewer&#8212;a finding that directly challenges the field&#8217;s working assumption that adding agents means adding capability.</p><p>I&#8217;d been operating on that assumption. The whole pitch for multi-agent systems is parallelism: more workers grinding on your problem means faster results. That&#8217;s how compute has always worked. But agents aren&#8217;t GPUs. They&#8217;re entities that need to coordinate, and coordination creates overhead that grows faster than capability. Past some threshold, most of your agents are effectively standing in line.</p><p>What got me digging deeper was noticing that the teams who&#8217;ve actually scaled past the prototype phase&#8212;Cursor running hundreds of agents on week-long autonomous coding, Steve Yegge orchestrating 20-30 simultaneously in Gas Town&#8212;weren&#8217;t comparing notes. They solved the same problem independently and landed on the same counterintuitive patterns. That kind of convergence usually means something real is going on underneath.</p><p>So I spent a couple weeks sorting through what they actually built versus what the frameworks recommend. The gap is uncomfortable. The industry consensus says agents should collaborate like human teams, share context, coordinate dynamically, operate continuously. The architectures that actually scale do almost none of that. They look too simple to work&#8212;until you understand why simplicity is the point.</p><p><strong>Here&#8217;s what&#8217;s inside:</strong></p><ul><li><p><strong>The scaling problem the frameworks don&#8217;t warn you about</strong> &#8212; Why coordination overhead compounds, and the research quantifying when it starts hurting more than helping.</p></li><li><p><strong>Six rules from the teams running hundreds of agents</strong> &#8212; The specific patterns Cursor and Yegge converged on independently, from strict two-tier hierarchies to treating agent endings as a feature rather than a bug.</p></li><li><p><strong>Where complexity should actually live</strong> &#8212; The case for dumb agents and smart orchestration, and why that inversion determines whether your system absorbs compute or chokes on it.</p></li><li><p><strong>What this means if you&#8217;re making bets in 2026</strong> &#8212; The questions that reveal whether a project or vendor has figured this out, and why Gartner&#8217;s prediction that over 40% of agentic AI projects will be canceled by the end of 2027 is probably right.</p></li></ul><p>Let me start with what the Google-MIT researchers actually found, because the numbers are more specific&#8212;and more uncomfortable&#8212;than the headline suggests.</p><div class=\"subscription-widget-wrap-editor\" data-attrs=\"{&quot;url&quot;:&quot;https://natesnewsletter.substack.com/subscribe?&quot;,&quot;text&quot;:&quot;Subscribe&quot;,&quot;language&quot;:&quot;en&quot;}\" data-component-name=\"SubscribeWidgetToDOM\"><div class=\"subscription-widget show-subscribe\"><div class=\"preamble\"><p class=\"cta-caption\">Subscribers get all posts like these!</p></div><form class=\"subscription-widget-subscribe\"><input type=\"email\" class=\"email-input\" name=\"email\" placeholder=\"Type your email&#8230;\" tabindex=\"-1\"><input type=\"submit\" class=\"button primary\" value=\"Subscribe\"><div class=\"fake-input-wrapper\"><div class=\"fake-input\"></div><div class=\"fake-button\"></div></div></form></div></div>\n      <p>\n          <a href=\"https://natesnewsletter.substack.com/p/why-dumb-agents-mean-smart-orchestration\">\n              Read more\n          </a>\n      </p>\n   ",
  "content_text": "A December 2025 study from Google and MIT found something I wasn’t expecting: adding more agents to a system can make it perform worse. Not diminishing returns—actual degradation. The researchers documented configurations where more agents produced worse outcomes than fewer—a finding that directly challenges the field’s working assumption that adding agents means adding capability.I’d been operating on that assumption. The whole pitch for multi-agent systems is parallelism: more workers grinding on your problem means faster results. That’s how compute has always worked. But agents aren’t GPUs. They’re entities that need to coordinate, and coordination creates overhead that grows faster than capability. Past some threshold, most of your agents are effectively standing in line.What got me digging deeper was noticing that the teams who’ve actually scaled past the prototype phase—Cursor running hundreds of agents on week-long autonomous coding, Steve Yegge orchestrating 20-30 simultaneously in Gas Town—weren’t comparing notes. They solved the same problem independently and landed on the same counterintuitive patterns. That kind of convergence usually means something real is going on underneath.So I spent a couple weeks sorting through what they actually built versus what the frameworks recommend. The gap is uncomfortable. The industry consensus says agents should collaborate like human teams, share context, coordinate dynamically, operate continuously. The architectures that actually scale do almost none of that. They look too simple to work—until you understand why simplicity is the point.Here’s what’s inside:The scaling problem the frameworks don’t warn you about — Why coordination overhead compounds, and the research quantifying when it starts hurting more than helping.Six rules from the teams running hundreds of agents — The specific patterns Cursor and Yegge converged on independently, from strict two-tier hierarchies to treating agent endings as a feature rather than a bug.Where complexity should actually live — The case for dumb agents and smart orchestration, and why that inversion determines whether your system absorbs compute or chokes on it.What this means if you’re making bets in 2026 — The questions that reveal whether a project or vendor has figured this out, and why Gartner’s prediction that over 40% of agentic AI projects will be canceled by the end of 2027 is probably right.Let me start with what the Google-MIT researchers actually found, because the numbers are more specific—and more uncomfortable—than the headline suggests.Subscribers get all posts like these!\n      \n          \n              Read more\n          \n      \n   ",
  "harvested_at": "2026-01-28T22:49:08.219230"
}